# Copyright (c) 2021 Andrew Archibald
#
# This Source Code Form is subject to the terms of the Mozilla Public
# License, v. 2.0. If a copy of the MPL was not distributed with this
# file, You can obtain one at https://mozilla.org/MPL/2.0/.

# printf prints a string on the stack with format verbs, stopping at -1.
#
# The format verbs are defined as follows:
#   -1 =>     end of string
#   -2 => %d  decimal
#   -3 => %b  binary
#   -4 => %o  octal
#   -5 => %x  hexadecimal
#   -6 => %#b binary with leading 0b
#   -7 => %#o octal with leading 0o
#   -8 => %#x hexadecimal with leading 0x
#
# (-1 str... -- )
printf:
    jn ^ .printf_verb
    printc
    jmp printf
.printf_verb:
    add 1 jz ^ .printf_ret         # -1
    add 1 jz ^ .printf_d           # -2
    add 1 jz ^ .printf_b           # -3
    add 1 jz ^ .printf_o           # -4
    add 1 jz ^ .printf_x           # -5
    add 1 jz ^ .printf_b_prefixed  # -6
    add 1 jz ^ .printf_o_prefixed  # -7
    add 1 jz ^ .printf_x_prefixed  # -8
    # fallthrough
.printf_ret:
    drop ret
.printf_d:
    drop printi jmp printf
.printf_b:
    drop call printi2 jmp printf
.printf_o:
    drop call printi8 jmp printf
.printf_x:
    drop call printi16 jmp printf
.printf_b_prefixed:
    drop call printi2_prefixed jmp printf
.printf_o_prefixed:
    drop call printi8_prefixed jmp printf
.printf_x_prefixed:
    drop call printi16_prefixed jmp printf

# prints prints a string on the stack, stopping at -1.
# (-1 str... -- )
prints:
    jn ^ .prints_eof
    printc
    jmp prints
.prints_eof:
    drop ret

# (x pad -- )
printi_pad0:
    swap call .print_sign
    call ^ .next_pow10
    swap push 10 call exp
    call max
    jmp .printu10

# (x -- )
printi2:
    call .print_sign
    call ^ .next_pow2
    jmp .printu2

# (x -- )
printi2_prefixed:
    call .print_sign
    printc '0' printc 'b'
    call ^ .next_pow2
    jmp .printu2

# (x pad -- )
printi2_pad0:
    swap call .print_sign
    call ^ .next_pow2
    swap push 2 call exp
    call max
    jmp .printu2

# (x pad -- )
printi2_prefixed_pad0:
    swap call .print_sign
    printc '0' printc 'b'
    call ^ .next_pow2
    swap push 2 call exp
    call max
    jmp .printu2

# (x -- )
printi8:
    call .print_sign
    call ^ .next_pow8
    jmp .printu8

# (x -- )
printi8_prefixed:
    call .print_sign
    printc '0' printc 'o'
    call ^ .next_pow8
    jmp .printu8

# (x pad -- )
printi8_pad0:
    swap call .print_sign
    call ^ .next_pow8
    swap push 8 call exp
    call max
    jmp .printu8

# (x pad -- )
printi8_prefixed_pad0:
    swap call .print_sign
    printc '0' printc 'o'
    call ^ .next_pow8
    swap push 8 call exp
    call max
    jmp .printu8

# (x -- )
printi16:
    call .print_sign
    call ^ .next_pow16
    jmp .printu16

# (x -- )
printi16_prefixed:
    call .print_sign
    printc '0' printc 'x'
    call ^ .next_pow16
    jmp .printu16

# (x pad -- )
printi16_pad0:
    swap call .print_sign
    call ^ .next_pow16
    swap push 16 call exp
    call max
    jmp .printu16

# (x pad -- )
printi16_prefixed_pad0:
    swap call .print_sign
    printc '0' printc 'x'
    call ^ .next_pow16
    swap push 16 call exp
    call max
    jmp .printu16

# Requires x>=0 && pow2>=x
# (x pow2 -- )
.printu2:
    div 2
    jz ^ .printu2_ret
    div ^1 ^1 mod 2 printi
    jmp .printu2
.printu2_ret:
    drop drop
    ret

# Requires x>=0 && pow8>=x
# (x pow8 -- )
.printu8:
    div 8
    jz ^ .printu8_ret
    div ^1 ^1 mod 8 printi
    jmp .printu8
.printu8_ret:
    drop drop
    ret

# Requires x>=0 && pow10>=x
# (x pow10 -- )
.printu10:
    div 10
    jz ^ .printu10_ret
    div ^1 ^1 mod 10 printi
    jmp .printu10
.printu10_ret:
    drop drop
    ret

# Requires x>=0 && pow16>=x
# (x pow16 -- )
.printu16:
    div 16
    jz ^ .printu16_ret
    div ^1 ^1 mod 16
    sub ^ 10 jn .printu16_10
    add 87 printc  # 87=='a'-10
    jmp .printu16
.printu16_10:
    printi
    jmp .printu16
.printu16_ret:
    drop drop
    ret

# (x -- |x|)
.print_sign:
    jn ^ .print_sign_neg
    ret
.print_sign_neg:
    mul -1
    printc '-'
    ret

# .next_pow2 returns the next power of 2 greater than or equal to x.
# Requires x>=0
# (x -- pow2)
.next_pow2:
    push 2
.next_pow2_loop:
    swap
    div 2
    jz ^ .next_pow2_ret
    swap
    mul 2
    jmp .next_pow2_loop
.next_pow2_ret:
    drop
    ret

# .next_pow8 returns the next power of 8 greater than or equal to x.
# Requires x>=0
# (x -- pow8)
.next_pow8:
    push 8
.next_pow8_loop:
    swap
    div 8
    jz ^ .next_pow8_ret
    swap
    mul 8
    jmp .next_pow8_loop
.next_pow8_ret:
    drop
    ret

# .next_pow10 returns the next power of 10 greater than or equal to x.
# Requires x>=0
# (x -- pow10)
.next_pow10:
    push 10
.next_pow10_loop:
    swap
    div 10
    jz ^ .next_pow10_ret
    swap
    mul 10
    jmp .next_pow10_loop
.next_pow10_ret:
    drop
    ret

# .next_pow16 returns the next power of 16 greater than or equal to x.
# Requires x>=0
# (x -- pow16)
.next_pow16:
    push 16
.next_pow16_loop:
    swap
    div 16
    jz ^ .next_pow16_ret
    swap
    mul 16
    jmp .next_pow16_loop
.next_pow16_ret:
    drop
    ret
