# Copyright (c) 2021 Andrew Archibald
#
# This Source Code Form is subject to the terms of the Mozilla Public
# License, v. 2.0. If a copy of the MPL was not distributed with this
# file, You can obtain one at https://mozilla.org/MPL/2.0/.

# printf prints a string on the stack with format verbs, stopping at -1.
#
# The format verbs are defined as follows:
#
#       -1  =>      end of string
#     x -2  => %d   decimal
#     x -3  => %b   binary
#     x -4  => %o   octal
#     x -5  => %x   hexadecimal
#     x -6  => %#b  binary with 0b prefix
#     x -7  => %#o  octal with 0o prefix
#     x -8  => %#x  hexadecimal with 0x prefix
# x pad -9  => %0nb binary with 0 padding
# x pad -10 => %0no octal with 0 padding
# x pad -11 => %0nx hexadecimal with 0 padding
#     c -12 => %q   quoted char
#  s... -13 => %s   string
#
# (-1 str... -- )
printf:
    jn ^ .printf_verb
    printc
    jmp printf
.printf_verb:
    add 1 jz ^ .printf_ret         # -1
    add 1 jz ^ .printf_d           # -2
    add 1 jz ^ .printf_b           # -3
    add 1 jz ^ .printf_o           # -4
    add 1 jz ^ .printf_x           # -5
    add 1 jz ^ .printf_b_prefixed  # -6
    add 1 jz ^ .printf_o_prefixed  # -7
    add 1 jz ^ .printf_x_prefixed  # -8
    add 1 jz ^ .printf_b_pad0      # -9
    add 1 jz ^ .printf_o_pad0      # -10
    add 1 jz ^ .printf_x_pad0      # -11
    add 1 jz ^ .printf_q           # -12
    add 1 jz ^ .printf_s           # -13
    printc '!'
    # fallthrough
.printf_ret:
    drop ret
.printf_d:
    drop printi jmp printf
.printf_b:
    drop call 2 printi_base jmp printf
.printf_o:
    drop call 8 printi_base jmp printf
.printf_x:
    drop call 16 printi_base jmp printf
.printf_b_prefixed:
    drop call 2 printi_base_prefixed jmp printf
.printf_o_prefixed:
    drop call 8 printi_base_prefixed jmp printf
.printf_x_prefixed:
    drop call 16 printi_base_prefixed jmp printf
.printf_b_pad0:
    jmp 2 .printf_pad0
.printf_o_pad0:
    jmp 8 .printf_pad0
.printf_x_pad0:
    jmp 16 .printf_pad0
.printf_q:
    drop call printc_quote jmp printf
.printf_s:
    drop call printf jmp printf
.printf_pad0:
    slide 1 swap copy 2 swap  # (x pad verb base -- x base x pad)
    call printi_base_pad0
    drop
    jmp printf

# prints0 prints a string on the stack, terminated with 0.
# (0 str... -- )
prints0:
    jz ^ .prints0_eof
    printc
    jmp prints0
.prints0_eof:
    drop ret

# printi_base prints x in the given base. The alphabet is [0-9a-z] for
# bases 2..=36 and [0-9A-Za-z] for bases 37..=62.
# Requires 2<=base<=62
# (x base -- )
printi_base:
    swap
    call .print_sign
.printu_base:
    call ^ ^2 .next_pow
.printu_base_pad0:
    sub ^1 11 jn .printu_base10
    sub ^1 37 jn .printu_base36
    jmp .printu_base62

# printi_base_prefixed prints x in the given base with a 0b prefix for
# base 2, 0o for base 8, or 0x for base 16. The alphabet is [0-9a-z] for
# bases 2..=36 and [0-9A-Za-z] for bases 37..=62.
# Requires 2<=base<=62
# (x base -- )
printi_base_prefixed:
    swap
    call .print_sign
    call ^1 .print_base_prefix
    jmp .printu_base

# printi_base_pad0 prints x in the given base, padded to at least pad
# digits.
# Requires 2<=base<=62 && base**n==pad
# (base x pad -- )
printi_base_pad0:
    swap
    call .print_sign
    swap
    call ^2 exp
    call ^1 ^3 .next_pow
    call max
    jmp .printu_base_pad0

# .print_sign prints '-' for negative numbers and returns the absolute
# value.
# (x -- |x|)
.print_sign:
    jn ^ .print_sign_neg
    ret
.print_sign_neg:
    mul -1
    printc '-'
    ret

# .print_base_prefix prints the prefix for a number: 0b for base 2, 0o
# for base 8, and 0x for base 16.
# (base -- )
.print_base_prefix:
    sub ^ 2 jz .print_base_2_prefix
    sub ^ 8 jz .print_base_8_prefix
    sub ^ 16 jz .print_base_16_prefix
    drop
    ret
.print_base_2_prefix:
    jmp 'b' .print_base_prefix_ret
.print_base_8_prefix:
    jmp 'o' .print_base_prefix_ret
.print_base_16_prefix:
    push 'x' # fallthrough
.print_base_prefix_ret:
    printc '0' printc
    drop
    ret

# .next_pow returns the next power of base greater than or equal to x.
# Requires x>=0 && base>=2
# (x base -- pow)
.next_pow:
    swap
    copy 1
.next_pow_loop:
    swap
    div ^2
    jz ^ .next_pow_ret
    swap
    mul ^2
    jmp .next_pow_loop
.next_pow_ret:
    drop swap drop
    ret

# .printu_base10 prints x in the given base with the alphabet [0-9].
# Requires 2<=base<=10 && 0<=x<=pow
# (base x pow -- )
.printu_base10:
    # pow /= base
    div ^2
    jz ^ .printu_base10_ret
    # print x/pow % base
    div ^1 ^1 mod ^3 printi
    jmp .printu_base10
.printu_base10_ret:
    drop 3
    ret

# .printu_base36 prints x in the given base with the alphabet [0-9a-z].
# Requires 2<=base<=36 && 0<=x<=pow
# (base x pow -- )
.printu_base36:
    # pow /= base
    div ^2
    jz ^ .printu_base36_ret
    div ^1 ^1 mod ^3
    sub ^ 10 jn .printu_base36_10
    # print (x/pow % base) - 10 + 'a'
    add 87 printc
    jmp .printu_base36
.printu_base36_10:
    # print x/pow % base
    printi
    jmp .printu_base36
.printu_base36_ret:
    drop 3
    ret

# .printu_base62 prints x in the given base with the alphabet
# [0-9A-Za-z].
# Requires 2<=base<=62 && 0<=x<=pow
# (base x pow -- )
.printu_base62:
    # pow /= base
    div ^2
    jz ^ .printu_base62_ret
    div ^1 ^1 mod ^3
    sub ^ 10 jn .printu_base62_10
    sub ^ 36 jn .printu_base62_36
    # print (x/pow % base) - 36 + 'a'
    add 61 printc
    jmp .printu_base62
.printu_base62_10:
    # print x/pow % base
    printi
    jmp .printu_base62
.printu_base62_36:
    # print (x/pow % base) - 10 + 'A'
    add 55 printc
    jmp .printu_base62
.printu_base62_ret:
    drop 3
    ret

# printc_quote prints a quoted character with escape sequences for
# ASCII control characters.
printc_quote:
    printc '\''
    call printc_escape
    printc '\''
    ret

# printc_escape prints a character with escape sequences for ASCII
# control characters.
# (c -- )
printc_escape:
    sub ^ ' ' jn .printc_escape_control
    sub ^ '\'' jz .printc_escape_slash
    sub ^ '\\' jz .printc_escape_slash
.printc_escape_ret:
    printc
    ret
.printc_escape_slash:
    printc '\\'
    jmp .printc_escape_ret
.printc_escape_control:
    printc '\\'
    sub ^ '\a' jz .printc_escape_a
    sub ^ '\b' jz .printc_escape_b
    sub ^ '\t' jz .printc_escape_t
    sub ^ '\n' jz .printc_escape_n
    sub ^ '\v' jz .printc_escape_v
    sub ^ '\f' jz .printc_escape_f
    sub ^ '\r' jz .printc_escape_r
    sub ^ '\e' jz .printc_escape_e
    printc 'x'
    push 16 swap push 2
    call printi_base_pad0
    ret
.printc_escape_a:
    jmp 'a' .printc_escape_ret
.printc_escape_b:
    jmp 'b' .printc_escape_ret
.printc_escape_t:
    jmp 't' .printc_escape_ret
.printc_escape_n:
    jmp 'n' .printc_escape_ret
.printc_escape_v:
    jmp 'v' .printc_escape_ret
.printc_escape_f:
    jmp 'f' .printc_escape_ret
.printc_escape_r:
    jmp 'r' .printc_escape_ret
.printc_escape_e:
    jmp 'e' .printc_escape_ret
